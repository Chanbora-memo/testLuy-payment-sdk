This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.gitignore
.repomixignore
config.js
index.js
package.json
validation.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
repomix-output.txt

node_modules/
test.js
</file>

<file path=".repomixignore">
# Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/

./node_modules

repomix.config.json
sdk_codebase.xml
repomix-output.txt
README.md
CHANGELOG.md
</file>

<file path="config.js">
// const config = {
//   clientId: process.env.TESTLUY_CLIENT_ID,
//   secretKey: process.env.TESTLUY_SECRET_KEY,
//   baseUrl: process.env.TESTLUY_BASE_URL || "http://localhost:8000/api",
// };

// export const getConfig = (options = {}) => {
//   const clientId = options.clientId || config.clientId;
//   const secretKey = options.secretKey || config.secretKey;
//   const baseUrl = options.baseUrl || config.baseUrl;

//   if (!clientId || !secretKey) {
//     console.warn(
//       "Warning: Client ID or Secret Key is missing. Ensure TESTLUY_CLIENT_ID and TESTLUY_SECRET_KEY environment variables are set."
//     );
//   }

//   return {
//     clientId,
//     secretKey,
//     baseUrl,
//   };
// };

const defaultConfig = { // Only default Base URL here if needed
  baseUrl: process.env.TESTLUY_BASE_URL || "http://localhost:8000/api",
};

export const getConfig = (options = {}) => {
  const clientId = options.clientId; // Get from options, no default from process.env in config
  const secretKey = options.secretKey; // Get from options, no default from process.env in config
  const baseUrl = options.baseUrl || defaultConfig.baseUrl;

  return {
    clientId,
    secretKey,
    baseUrl,
  };
};
</file>

<file path="index.js">
import axios from "axios";
import { getConfig } from "./config.js";
import {
  validateAmount,
  validateCallbackUrl,
  validateTransactionId,
} from "./validation.js";

/**
 * TestluyPaymentSDK - A payment processing SDK for integrating with the Testluy payment system
 * @class
 * @description Handles payment processing operations including payment URL generation, status checking, and callback handling
 */
class TestluyPaymentSDK {
  constructor(options = {}) {
    const { clientId, secretKey, baseUrl } = getConfig(options);
    if (!clientId || !secretKey) {
      throw new Error("Client ID and Secret Key are required.");
    }
    // Ensure baseUrl doesn't end with a slash
    this.baseUrl = baseUrl.endsWith('/') ? baseUrl.slice(0, -1) : baseUrl;
    if (!this.baseUrl.startsWith('http://') && !this.baseUrl.startsWith('https://')) {
      console.warn(`Warning: Base URL "${this.baseUrl}" might be invalid. Ensure it includes http:// or https://`);
    }
    this.clientId = clientId;
    this.secretKey = secretKey;
    this.isValidated = false;
  }

  /**
   * Generate HMAC signature for request using Web Crypto API
   * @private
   */
  async _generateSignature(method, path, timestamp, body = '') {
    const encoder = new TextEncoder();
    // Ensure body is consistently stringified for POST/PUT, or empty string for GET/DELETE
    const bodyString = (method === 'POST' || method === 'PUT')
                       ? (typeof body === 'string' ? body : JSON.stringify(body))
                       : '';

    const stringToSign = method + '\n' +
                        path + '\n' +
                        timestamp + '\n' +
                        bodyString;

    // Convert secret key to Uint8Array
    const keyData = encoder.encode(this.secretKey);

    // Import the key for HMAC
    const key = await crypto.subtle.importKey(
      'raw',
      keyData,
      { name: 'HMAC', hash: 'SHA-256' },
      false,
      ['sign']
    );

    // Create the signature
    const signature = await crypto.subtle.sign(
      'HMAC',
      key,
      encoder.encode(stringToSign)
    );

    // Convert to hex string
    const hexSignature = Array.from(new Uint8Array(signature))
      .map(b => b.toString(16).padStart(2, '0'))
      .join('');
    
    return hexSignature;
  }

  /**
   * Get authentication headers for request
   * @private
   */
  async _getAuthHeaders(method, path, body = '') {
    const timestamp = Math.floor(Date.now() / 1000).toString();
    // ***** Pass the actual body intended for the request to _generateSignature *****
    const signature = await this._generateSignature(method, path, timestamp, body);

    return {
      'X-Client-ID': this.clientId,
      'X-Timestamp': timestamp,
      'X-Signature': signature,
      'Content-Type': 'application/json',
    };
  }

  async init() {
    if (!this.clientId || !this.secretKey) {
      throw new Error("Client ID and Secret Key are required.");
    }
    try {
      this.isValidated = await this.validateCredentials();
      if (!this.isValidated) {
        // Provide a more specific error based on potential validateCredentials failure
         throw new Error("Invalid credentials or inactive/in-use application subscription.");
      }
      console.log("SDK Credentials Validated Successfully.");
    } catch (error) {
        // Log the underlying error message if available
      console.error("Failed to validate credentials:", error.message);
       // Re-throw the specific error from validateCredentials or a generic one
       throw new Error(`SDK Initialization failed: ${error.message || 'Could not validate credentials.'}`);
    }
  }

  async generatePaymentUrl(amount, callbackUrl) {
    try {
      validateAmount(amount);
      validateCallbackUrl(callbackUrl);

      // ***** FIX: Prepend 'api/' to the path *****
      const path = 'api/payment-simulator/generate-url';
      const body = {
        amount: amount,
        callback_url: callbackUrl
      };
      const fullUrl = `${this.baseUrl}/${path}`;
      // console.log("POST Request URL:", fullUrl); // Debugging
      // console.log("Request Body:", JSON.stringify(body)); // Debugging

      const response = await axios.post(
        fullUrl,
        body,
        {
          // ***** Pass the correct path and body for signing *****
          headers: await this._getAuthHeaders('POST', path, body)
        }
      );
      return response.data.payment_url;
    } catch (error) {
       // Enhanced error logging
       const errorData = error.response?.data;
       const errorMessage = (errorData?.message || errorData?.error || error.message);
       console.error(
         "Generate payment URL error:",
         errorData ? JSON.stringify(errorData) : error.message // Log full response data if available
       );
       // Throw a more specific error
       throw new Error(`Failed to generate payment URL: ${errorMessage}`);
    }
  }

  async getPaymentStatus(transactionId) {
    try {
      validateTransactionId(transactionId);

      // ***** FIX: Prepend 'api/' to the path *****
      const path = `api/payment-simulator/status/${transactionId}`;
      const fullUrl = `${this.baseUrl}/${path}`;
      // console.log("GET Request URL:", fullUrl); // Debugging

      const response = await axios.get(
        fullUrl,
        {
          // ***** Pass the correct path for signing (body is implicitly empty for GET) *****
          headers: await this._getAuthHeaders('GET', path) // No body needed for GET signature here
        }
      );
      return response.data;
    } catch (error) {
      const errorData = error.response?.data;
      const errorMessage = (errorData?.message || errorData?.error || error.message);
      console.error(
          `Error fetching payment status for ${transactionId}:`,
          errorData ? JSON.stringify(errorData) : error.message
      );
      throw new Error(`Failed to get payment status: ${errorMessage}`);
    }
  }

  async validateCredentials() {
    try {
      // ***** FIX: Prepend 'api/' to the path *****
      const path = 'api/validate-credentials';
      const body = {}; // Explicitly define the empty body being sent
      const fullUrl = `${this.baseUrl}/${path}`;
      // console.log("POST Request URL for Validation:", fullUrl); // Debugging

      const response = await axios.post(
        fullUrl,
        body, // Send the empty body
        {
          // ***** Pass the correct path and the empty body object for signing *****
          headers: await this._getAuthHeaders('POST', path, body)
        }
      );
      return response.data.isValid;
    } catch (error) {
      const errorData = error.response?.data;
      const errorMessage = (errorData?.message || errorData?.error || error.message);
      console.error(
        "Validation error:",
        errorData ? JSON.stringify(errorData) : error.message
      );
      // Throwing the error is generally better than returning false,
      // as it indicates *why* validation failed (e.g., network error vs. invalid key)
      // The caller (like init) can then handle it appropriately.
      throw new Error(`Credentials validation failed: ${errorMessage}`);
      // return false; // Original behavior if preferred
    }
  }

  async initiatePaymentFlow(amount, callbackUrl, backUrl) {
    try {
      validateAmount(amount);
      validateCallbackUrl(callbackUrl); // Assuming backUrl is optional or validated elsewhere if needed

      // ***** FIX: Prepend 'api/' to the path *****
      const path = 'api/payment-simulator/generate-url';
      const body = {
        amount,
        callback_url: callbackUrl,
        // Conditionally add back_url ONLY if it has a value,
        // to ensure the body signed matches exactly what's sent.
        ...(backUrl && { back_url: backUrl })
      };
      const fullUrl = `${this.baseUrl}/${path}`;
      // console.log("POST Request URL (Flow):", fullUrl); // Debugging
      // console.log("Request Body (Flow):", JSON.stringify(body)); // Debugging

      const response = await axios.post(
        fullUrl,
        body,
        {
           // ***** Pass the correct path and body for signing *****
          headers: await this._getAuthHeaders('POST', path, body)
        }
      );

      const { payment_url, transaction_id } = response.data;

      if (!payment_url || !transaction_id) { // Check both fields returned
        console.error("Server response missing payment_url or transaction_id", response.data);
        throw new Error("Incomplete response received from the server.");
      }

      return {
        paymentUrl: payment_url,
        transactionId: transaction_id,
        // backUrl: backUrl, // No need to return this, it was an input
        // The handleCallback function reference remains useful
        handleCallback: this.handlePaymentCallback.bind(this)
      };
    } catch (error) {
      const errorData = error.response?.data;
      const errorMessage = (errorData?.message || errorData?.error || error.message);
      console.error(
          "Error in initiatePaymentFlow:",
          errorData ? JSON.stringify(errorData) : error.message
      );
      throw new Error(`Failed to initiate payment flow: ${errorMessage}`);
    }
  }

  // handlePaymentCallback calls getPaymentStatus which is now fixed, so no direct changes needed here.
  async handlePaymentCallback(callbackData, callbackUrl) {
    try {
      // Validate input callbackData minimally
      if (!callbackData || typeof callbackData !== 'object') {
          throw new Error("Invalid callback data received.");
      }
      const { transaction_id, status } = callbackData;

      if (!transaction_id) {
        throw new Error("Transaction ID is missing in callback data.");
      }
       // It's safer to rely on the status fetched from the backend via getPaymentStatus
      const paymentStatusDetails = await this.getPaymentStatus(transaction_id);

      return {
        transactionId: transaction_id,
        // Use the verified status from the backend API call
        status: paymentStatusDetails.status, // e.g., 'Success', 'Failed', 'Initiated'
        paymentDetails: paymentStatusDetails,
        // receivedCallbackStatus: status, // Optionally keep the status received in the callback
        callbackUrl: callbackUrl // The URL the callback was POSTed to (if needed)
      };
    } catch (error) {
      // Error could be from getPaymentStatus or input validation
      console.error("Error in handlePaymentCallback:", error.message);
      // Propagate the specific error message
      throw new Error(`Failed to handle payment callback: ${error.message}`);
    }
  }
}

console.log("TestluyPaymentSDK loaded");
export default TestluyPaymentSDK;
</file>

<file path="package.json">
{
  "name": "testluy-payment-sdk",
  "version": "2.0.3",
  "description": "SDK for TestLuy Payment Simulator",
  "main": "index.js",
  "type": "module",
  "scripts": {
    "test": "node test.js"
  },
  "keywords": [
    "payment",
    "simulator",
    "sdk"
  ],
  "author": "Chanbora Seng",
  "license": "MIT",
  "dependencies": {
    "axios": "^1.7.3",
    "dotenv": "^16.4.7",
    "joi": "^17.13.3"
  },
  "devDependencies": {
    "jest": "^29.7.0"
  }
}
</file>

<file path="validation.js">
import Joi from 'joi';

const amountSchema = Joi.number().positive().required().messages({
  'number.base': '"amount" must be a number',
  'number.positive': '"amount" must be a positive number',
  'any.required': '"amount" is required'
});

const callbackUrlSchema = Joi.string().uri().required().messages({
  'string.base': '"callbackUrl" must be a string',
  'string.uri': '"callbackUrl" must be a valid URI',
  'any.required': '"callbackUrl" is required'
});

const transactionIdSchema = Joi.string().required().messages({
  'string.base': '"transactionId" must be a string',
  'any.required': '"transactionId" is required'
});

export const validateAmount = (amount) => {
  const { error } = amountSchema.validate(amount);
  if (error) {
    throw new Error(error.details[0].message);
  }
};

export const validateCallbackUrl = (callbackUrl) => {
  const { error } = callbackUrlSchema.validate(callbackUrl);
  if (error) {
    throw new Error(error.details[0].message);
  }
};

export const validateTransactionId = (transactionId) => {
    const { error } = transactionIdSchema.validate(transactionId);
    if (error) {
      throw new Error(error.details[0].message);
    }
  };
</file>

</files>
