This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.gitignore
.repomixignore
CHANGELOG.md
config.js
index.js
package.json
README.md
validation.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
repomix-output.txt

node_modules/
test.js
</file>

<file path=".repomixignore">
# Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/

./node_modules

repomix.config.json
</file>

<file path="CHANGELOG.md">
# Changelog

## Version 2.0.0

### Security Enhancement: HMAC Authentication

The SDK has been updated to use HMAC-based authentication instead of Basic Authentication for improved security. This change provides:

- Request signing to prevent request tampering
- Timestamp validation to prevent replay attacks
- More secure credential handling

### Required Changes

1. Update your SDK dependency to version 2.0.0 or later:

```bash
npm install testluy-payment-sdk@latest
```

2. No code changes are required - the SDK handles all authentication changes internally:

```javascript
const sdk = new TestluyPaymentSDK({\n  clientId: 'your_client_id',\n  secretKey: 'your_secret_key'\n});
```

### Breaking Changes

- Removed Basic Authentication headers
- Added HMAC signature verification
- Added request timestamp validation (requests must be within 5 minutes of server time)

### Security Benefits

1. **Improved Security**: HMAC signatures ensure request integrity and authenticity
2. **No Exposed Credentials**: Credentials**Replay Protection**: Timestamp validation prevents replay attacks
3. **No Exposed Credentials**: Credentials are never sent directly in requests
4. **Request Integrity**: All requests are signed to prevent tampering

### Compatibility

The SDK maintains backward compatibility with all existing methods:

- `generatePaymentUrl()`
- `getPaymentStatus()`
- `validateCredentials()`
- `initiatePaymentFlow()`
- `handlePaymentCallback()`

Only the authentication mechanism has changed; all method signatures remain the same.
</file>

<file path="config.js">
// const config = {
//   clientId: process.env.TESTLUY_CLIENT_ID,
//   secretKey: process.env.TESTLUY_SECRET_KEY,
//   baseUrl: process.env.TESTLUY_BASE_URL || "http://localhost:8000/api",
// };

// export const getConfig = (options = {}) => {
//   const clientId = options.clientId || config.clientId;
//   const secretKey = options.secretKey || config.secretKey;
//   const baseUrl = options.baseUrl || config.baseUrl;

//   if (!clientId || !secretKey) {
//     console.warn(
//       "Warning: Client ID or Secret Key is missing. Ensure TESTLUY_CLIENT_ID and TESTLUY_SECRET_KEY environment variables are set."
//     );
//   }

//   return {
//     clientId,
//     secretKey,
//     baseUrl,
//   };
// };

const defaultConfig = { // Only default Base URL here if needed
  baseUrl: process.env.TESTLUY_BASE_URL || "http://localhost:8000/api",
};

export const getConfig = (options = {}) => {
  const clientId = options.clientId; // Get from options, no default from process.env in config
  const secretKey = options.secretKey; // Get from options, no default from process.env in config
  const baseUrl = options.baseUrl || defaultConfig.baseUrl;

  return {
    clientId,
    secretKey,
    baseUrl,
  };
};
</file>

<file path="index.js">
import axios from "axios";
import { getConfig } from "./config.js";
import {
  validateAmount,
  validateCallbackUrl,
  validateTransactionId,
} from "./validation.js";

/**
 * TestluyPaymentSDK - A payment processing SDK for integrating with the Testluy payment system
 * @class
 * @description Handles payment processing operations including payment URL generation, status checking, and callback handling
 */
class TestluyPaymentSDK {
  constructor(options = {}) {
    const { clientId, secretKey, baseUrl } = getConfig(options);
    if (!clientId || !secretKey) {
      throw new Error("Client ID and Secret Key are required.");
    }
    this.clientId = clientId;
    this.secretKey = secretKey;
    this.baseUrl = baseUrl;
    this.isValidated = false;
  }

  /**
   * Generate HMAC signature for request using Web Crypto API
   * @private
   */
  async _generateSignature(method, path, timestamp, body = '') {
    const encoder = new TextEncoder();
    const stringToSign = method + '\n' + 
                        path + '\n' + 
                        timestamp + '\n' + 
                        (typeof body === 'string' ? body : JSON.stringify(body));
    
    // Convert secret key to Uint8Array
    const keyData = encoder.encode(this.secretKey);
    
    // Import the key for HMAC
    const key = await crypto.subtle.importKey(
      'raw',
      keyData,
      { name: 'HMAC', hash: 'SHA-256' },
      false,
      ['sign']
    );
    
    // Create the signature
    const signature = await crypto.subtle.sign(
      'HMAC',
      key,
      encoder.encode(stringToSign)
    );

    // Convert to hex string
    return Array.from(new Uint8Array(signature))
      .map(b => b.toString(16).padStart(2, '0'))
      .join('');
  }

  /**
   * Get authentication headers for request
   * @private
   */
  async _getAuthHeaders(method, path, body = '') {
    const timestamp = Math.floor(Date.now() / 1000).toString();
    const signature = await this._generateSignature(method, path, timestamp, body);

    return {
      'X-Client-ID': this.clientId,
      'X-Timestamp': timestamp,
      'X-Signature': signature,
      'Content-Type': 'application/json'
    };
  }

  async init() {
    if (!this.clientId || !this.secretKey) {
      throw new Error("Client ID and Secret Key are required.");
    }
    try {
      this.isValidated = await this.validateCredentials();
      if (!this.isValidated) {
        throw new Error("Invalid credentials");
      }
    } catch (error) {
      console.error("Failed to validate credentials:", error.message);
      throw error;
    }
  }

  async generatePaymentUrl(amount, callbackUrl) {
    try {
      validateAmount(amount);
      validateCallbackUrl(callbackUrl);
      
      const path = 'payment-simulator/generate-url';
      const body = {
        amount: amount,
        callback_url: callbackUrl
      };

      const response = await axios.post(
        `${this.baseUrl}/${path}`,
        body,
        {
          headers: await this._getAuthHeaders('POST', path, body)
        }
      );
      return response.data.payment_url;
    } catch (error) {
      console.error(
        "Generate payment URL error:",
        error.response ? error.response.data : error.message
      );
      throw new Error(
        `Failed to generate payment URL: ${
          error.response ? error.response.data.message : error.message
        }`
      );
    }
  }

  async getPaymentStatus(transactionId) {
    try {
      validateTransactionId(transactionId);
      const path = `payment-simulator/status/${transactionId}`;
      
      const response = await axios.get(
        `${this.baseUrl}/${path}`,
        {
          headers: await this._getAuthHeaders('GET', path)
        }
      );
      return response.data;
    } catch (error) {
      console.error(`Error fetching payment status:`, error);
      throw new Error(`Failed to get payment status: ${error.message}`);
    }
  }

  async validateCredentials() {
    try {
      const path = 'validate-credentials';
      const response = await axios.post(
        `${this.baseUrl}/${path}`,
        {},
        {
          headers: await this._getAuthHeaders('POST', path)
        }
      );
      return response.data.isValid;
    } catch (error) {
      console.error(
        "Validation error:",
        error.response ? error.response.data : error.message
      );
      return false;
    }
  }

  async initiatePaymentFlow(amount, callbackUrl, backUrl) {
    try {
      validateAmount(amount);
      validateCallbackUrl(callbackUrl);
      
      const path = 'payment-simulator/generate-url';
      const body = {
        amount,
        callback_url: callbackUrl,
        back_url: backUrl
      };

      const response = await axios.post(
        `${this.baseUrl}/${path}`,
        body,
        {
          headers: await this._getAuthHeaders('POST', path, body)
        }
      );

      const { payment_url, transaction_id } = response.data;

      if (!transaction_id) {
        throw new Error("Transaction ID not returned from the server");
      }

      return {
        paymentUrl: payment_url,
        transactionId: transaction_id,
        backUrl: backUrl,
        handleCallback: this.handlePaymentCallback.bind(this)
      };
    } catch (error) {
      console.error("Error in initiatePaymentFlow:", error.message);
      if (error.response) {
        console.error("Error response data:", error.response.data);
      }
      throw new Error(`Failed to initiate payment flow: ${error.message}`);
    }
  }

  async handlePaymentCallback(callbackData, callbackUrl) {
    try {
      const { transaction_id, status } = callbackData;
      if (!transaction_id) {
        throw new Error("Transaction ID is undefined");
      }
      const paymentStatus = await this.getPaymentStatus(transaction_id);
      return {
        transactionId: transaction_id,
        status: status,
        paymentDetails: paymentStatus,
        callbackUrl: callbackUrl
      };
    } catch (error) {
      console.error("Error in handlePaymentCallback:", error);
      throw new Error(`Failed to handle payment callback: ${error.message}`);
    }
  }
}

console.log("TestluyPaymentSDK loaded");
export default TestluyPaymentSDK;
</file>

<file path="package.json">
{
  "name": "testluy-payment-sdk",
  "version": "2.0.1",
  "description": "SDK for TestLuy Payment Simulator",
  "main": "index.js",
  "type": "module",
  "scripts": {
    "test": "node test.js"
  },
  "keywords": [
    "payment",
    "simulator",
    "sdk"
  ],
  "author": "Chanbora Seng",
  "license": "MIT",
  "dependencies": {
    "axios": "^1.7.3",
    "dotenv": "^16.4.7",
    "joi": "^17.13.3"
  },
  "devDependencies": {
    "jest": "^29.7.0"
  }
}
</file>

<file path="README.md">
# Testluy Payment Simulator SDK

This SDK provides easy integration with the Testluy Payment Simulator.

## Installation

```bash
npm install testluy-payment-sdk
```

## Usage
```javascript
const TestluyPaymentSDK = require('testluy-payment-sdk');
const sdk = new TestluyPaymentSDK('your-client-id', 'your-secret-key', 'http://your-api-base-url');
// Generate a payment URL
sdk.generatePaymentUrl(20.00, 'your-application-id', 'https://your-callback-url.com')
.then(paymentUrl => {
console.log('Payment URL:', paymentUrl);
})
.catch(error => {
console.error('Error:', error.message);
});
// Get payment status
sdk.getPaymentStatus('transaction-id')
.then(status => {
console.log('Payment Status:', status);
})
.catch(error => {
console.error('Error:', error.message);
});
```

## API Reference

### generatePaymentUrl(amount, applicationId, callbackUrl)

Generates a payment URL for the given amount and application.

### getPaymentStatus(transactionId)

Retrieves the status of a payment for the given transaction ID.
</file>

<file path="validation.js">
import Joi from 'joi';

const amountSchema = Joi.number().positive().required().messages({
  'number.base': '"amount" must be a number',
  'number.positive': '"amount" must be a positive number',
  'any.required': '"amount" is required'
});

const callbackUrlSchema = Joi.string().uri().required().messages({
  'string.base': '"callbackUrl" must be a string',
  'string.uri': '"callbackUrl" must be a valid URI',
  'any.required': '"callbackUrl" is required'
});

const transactionIdSchema = Joi.string().required().messages({
  'string.base': '"transactionId" must be a string',
  'any.required': '"transactionId" is required'
});

export const validateAmount = (amount) => {
  const { error } = amountSchema.validate(amount);
  if (error) {
    throw new Error(error.details[0].message);
  }
};

export const validateCallbackUrl = (callbackUrl) => {
  const { error } = callbackUrlSchema.validate(callbackUrl);
  if (error) {
    throw new Error(error.details[0].message);
  }
};

export const validateTransactionId = (transactionId) => {
    const { error } = transactionIdSchema.validate(transactionId);
    if (error) {
      throw new Error(error.details[0].message);
    }
  };
</file>

</files>
